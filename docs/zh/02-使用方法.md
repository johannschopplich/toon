# TOON 使用方法

本文档详细介绍如何在项目中安装和使用 TOON。

## 安装

### npm
```bash
npm install @byjohann/toon
```

### pnpm
```bash
pnpm add @byjohann/toon
```

### yarn
```bash
yarn add @byjohann/toon
```

## 基础使用

### 快速开始

```typescript
import { encode } from '@byjohann/toon'

const data = {
  user: {
    id: 123,
    name: 'Ada',
    tags: ['reading', 'gaming'],
    active: true,
    preferences: []
  }
}

console.log(encode(data))
```

输出：
```
user:
  id: 123
  name: Ada
  tags[2]: reading,gaming
  active: true
  preferences[0]:
```

## 格式详解

### 1. 对象（Objects）

#### 简单对象

包含原始值的对象：

```typescript
encode({
  id: 123,
  name: 'Ada',
  active: true
})
```

输出：
```
id: 123
name: Ada
active: true
```

#### 嵌套对象

```typescript
encode({
  user: {
    id: 123,
    name: 'Ada'
  }
})
```

输出：
```
user:
  id: 123
  name: Ada
```

#### 空对象

```typescript
encode({})                    // 空输出
encode({ config: {} })        // config:
```

### 2. 数组（Arrays）

TOON 对数组有多种编码方式，根据数组内容自动选择最优格式。

#### 原始值数组（内联格式）

```typescript
encode({
  tags: ['admin', 'ops', 'dev']
})
```

输出：
```
tags[3]: admin,ops,dev
```

**说明**：
- `[3]` 表示数组长度
- 使用逗号分隔值（默认分隔符）

#### 空数组

```typescript
encode({ items: [] })
```

输出：
```
items[0]:
```

#### 对象数组（表格格式）

当所有对象具有相同的原始值字段时，使用高效的**表格格式**：

```typescript
encode({
  items: [
    { sku: 'A1', qty: 2, price: 9.99 },
    { sku: 'B2', qty: 1, price: 14.5 }
  ]
})
```

输出：
```
items[2]{sku,qty,price}:
  A1,2,9.99
  B2,1,14.5
```

**表格格式要求**：
- 所有元素都是对象
- 所有对象具有相同的键集合
- 所有值都是原始类型（字符串、数字、布尔值、null）

**表格格式优势**：
- 字段名只声明一次
- 每行只包含值，大幅减少 token

#### 嵌套的表格格式

表格格式可以递归应用：

```typescript
encode({
  items: [
    {
      users: [
        { id: 1, name: 'Ada' },
        { id: 2, name: 'Bob' }
      ],
      status: 'active'
    }
  ]
})
```

输出：
```
items[1]:
  - users[2]{id,name}:
    1,Ada
    2,Bob
    status: active
```

#### 非统一数组（列表格式）

不满足表格格式要求的数组使用列表格式：

```typescript
encode({
  items: [
    { id: 1, name: 'First' },
    { id: 2, name: 'Second', extra: true }
  ]
})
```

输出：
```
items[2]:
  - id: 1
    name: First
  - id: 2
    name: Second
    extra: true
```

**注意**：当对象出现在列表格式中时，第一个字段放在连字符行上。

#### 混合类型数组

```typescript
encode({
  items: [1, { a: 1 }, 'text']
})
```

输出：
```
items[3]:
  - 1
  - a: 1
  - text
```

#### 数组的数组

```typescript
encode({
  pairs: [
    [1, 2],
    [3, 4]
  ]
})
```

输出：
```
pairs[2]:
  - [2]: 1,2
  - [2]: 3,4
```

#### 根数组

如果顶层就是数组：

```typescript
encode(['x', 'y'])
```

输出：
```
[2]: x,y
```

### 3. 引号规则

TOON **仅在必要时**才给字符串加引号，以最大化 token 效率。

#### 不需要引号的情况

```typescript
encode({
  text: 'hello world',       // 内部空格可以
  emoji: 'hello 👋 world',   // Unicode 和 emoji 可以
  chinese: '你好世界'         // 中文字符可以
})
```

输出：
```
text: hello world
emoji: hello 👋 world
chinese: 你好世界
```

#### 需要引号的情况

字符串在以下情况下**必须**加引号：

| 条件 | 示例 |
|------|------|
| 空字符串 | `""` |
| 前导或尾随空格 | `" padded "`, `"  "` |
| 包含活动分隔符、冒号、引号、反斜杠或控制字符 | `"a,b"`, `"a:b"`, `"say \"hi\""`, `"C:\\Users"` |
| 看起来像布尔值/数字/null | `"true"`, `"false"`, `"null"`, `"42"`, `"-3.14"` |
| 以 `"- "` 开头（类似列表） | `"- item"` |
| 看起来像结构标记 | `"[5]"`, `"{key}"` |

```typescript
encode({
  empty: '',
  spaced: ' padded ',
  withComma: 'a,b',
  withColon: 'key:value',
  likeBoolean: 'true',
  likeNumber: '42'
})
```

输出：
```
empty: ""
spaced: " padded "
withComma: "a,b"
withColon: "key:value"
likeBoolean: "true"
likeNumber: "42"
```

#### 对象键的引号规则

对象键如果是有效标识符（以字母或下划线开头，后跟字母、数字、下划线或点），可以不加引号：

```typescript
encode({
  id: 1,                    // 不需要引号
  userName: 'Ada',          // 不需要引号
  user_name: 'Ada',         // 不需要引号
  'user name': 'Ada',       // 需要引号（包含空格）
  'order-id': 1,            // 需要引号（包含连字符）
  '123': 1,                 // 需要引号（以数字开头）
})
```

输出：
```
id: 1
userName: Ada
user_name: Ada
"user name": Ada
"order-id": 1
"123": 1
```

### 4. 转义规则

在引号字符串中，以下字符需要转义：

| 字符 | 转义形式 |
|------|---------|
| 反斜杠 `\` | `\\` |
| 双引号 `"` | `\"` |
| 换行符 | `\n` |
| 回车符 | `\r` |
| 制表符 | `\t` |

```typescript
encode({
  path: 'C:\\Users\\Ada',
  quote: 'He said "Hello"',
  multiline: 'Line 1\nLine 2'
})
```

输出：
```
path: "C:\\Users\\Ada"
quote: "He said \"Hello\""
multiline: "Line 1\nLine 2"
```

## 高级选项

### API 签名

```typescript
function encode(value: unknown, options?: EncodeOptions): string

interface EncodeOptions {
  indent?: number           // 每级缩进的空格数，默认 2
  delimiter?: ',' | '\t' | '|'  // 分隔符，默认逗号
  lengthMarker?: '#' | false    // 长度标记，默认 false
}
```

### 自定义缩进

```typescript
// 默认使用 2 个空格
encode(data)

// 使用 4 个空格缩进
encode(data, { indent: 4 })
```

### 自定义分隔符

#### 逗号分隔符（默认）

```typescript
const data = {
  items: [
    { sku: 'A1', name: 'Widget', qty: 2 },
    { sku: 'B2', name: 'Gadget', qty: 1 }
  ]
}

encode(data)
// 或显式指定
encode(data, { delimiter: ',' })
```

输出：
```
items[2]{sku,name,qty}:
  A1,Widget,2
  B2,Gadget,1
```

#### 制表符分隔符

使用制表符可以进一步减少 token：

```typescript
encode(data, { delimiter: '\t' })
```

输出（制表符在头部显式标记）：
```
items[2	]{sku	name	qty}:
  A1	Widget	2
  B2	Gadget	1
```

**优势**：
- 制表符是单个字符，tokenize 更高效
- 自然文本中很少出现制表符，减少转义需求
- 分隔符在头部明确编码，自文档化

**注意事项**：
- 某些终端和编辑器可能会改变制表符的显示宽度
- 包含制表符的字符串值仍需要引号

#### 管道分隔符

管道符提供了逗号和制表符之间的中间选择：

```typescript
encode(data, { delimiter: '|' })
```

输出：
```
items[2|]{sku|name|qty}:
  A1|Widget|2
  B2|Gadget|1
```

#### 分隔符感知引号

重要特性：使用不同分隔符时，引号规则会自动调整。

```typescript
const data = { text: 'hello, world' }

// 使用逗号分隔符 - 需要引号
encode(data, { delimiter: ',' })
// text: "hello, world"

// 使用制表符分隔符 - 不需要引号（逗号不再是活动分隔符）
encode(data, { delimiter: '\t' })
// text: hello, world

// 使用管道分隔符 - 不需要引号
encode(data, { delimiter: '|' })
// text: hello, world
```

### 长度标记选项

添加 `#` 前缀来强调数组长度是计数值而非索引：

```typescript
const data = {
  tags: ['reading', 'gaming', 'coding'],
  items: [
    { sku: 'A1', qty: 2, price: 9.99 },
    { sku: 'B2', qty: 1, price: 14.5 }
  ]
}

encode(data, { lengthMarker: '#' })
```

输出：
```
tags[#3]: reading,gaming,coding
items[#2]{sku,qty,price}:
  A1,2,9.99
  B2,1,14.5
```

可以与自定义分隔符结合使用：

```typescript
encode(data, { lengthMarker: '#', delimiter: '|' })
```

输出：
```
tags[#3|]: reading|gaming|coding
items[#2|]{sku|qty|price}:
  A1|2|9.99
  B2|1|14.5
```

## 类型转换

TOON 会自动将某些非 JSON 类型转换为 LLM 安全的输出：

| 输入类型 | 输出 | 示例 |
|---------|------|------|
| 有限数字 | 十进制形式 | `1e6` → `1000000`<br>`-0` → `0` |
| NaN, ±Infinity | `null` | `NaN` → `null` |
| BigInt | 十进制数字字符串 | `9007199254740993n` → `"9007199254740993"` |
| Date | ISO 字符串 | `new Date('2025-01-01')` → `"2025-01-01T00:00:00.000Z"` |
| undefined | `null` | `undefined` → `null` |
| function | `null` | `() => {}` → `null` |
| symbol | `null` | `Symbol()` → `null` |
| Set | 数组 | `new Set([1, 2])` → `[2]: 1,2` |
| Map | 对象 | `new Map([['a', 1]])` → `a: 1` |

示例：

```typescript
encode({
  count: 1e6,
  negative_zero: -0,
  invalid: NaN,
  big: 9007199254740993n,
  timestamp: new Date('2025-01-01'),
  missing: undefined,
  fn: () => {},
  tags: new Set(['a', 'b']),
  config: new Map([['key', 'value']])
})
```

输出：
```
count: 1000000
negative_zero: 0
invalid: null
big: "9007199254740993"
timestamp: "2025-01-01T00:00:00.000Z"
missing: null
fn: null
tags[2]: a,b
config:
  key: value
```

## 在 LLM 提示中使用 TOON

### 向 LLM 发送数据（输入）

将编码后的数据包装在代码块中（建议标记为 \`\`\`toon）：

````markdown
数据采用 TOON 格式（2 空格缩进，数组显示长度和字段）。

```toon
users[3]{id,name,role,lastLogin}:
  1,Alice,admin,2025-01-15T10:30:00Z
  2,Bob,user,2025-01-14T15:22:00Z
  3,Charlie,user,2025-01-13T09:45:00Z
```

请找出所有 role 为 "user" 的用户。
````

### 让 LLM 生成 TOON（输出）

如果需要 LLM **生成** TOON 格式的数据，需要更明确的指示：

````markdown
请将结果以 TOON 格式返回。规则：
- 2 空格缩进
- 无行尾空格
- [N] 必须匹配行数

使用此头部格式：
```
users[N]{id,name,role}:
```

任务：返回 role 为 "user" 的用户。只输出代码块。
````

### 使用制表符优化

对于大型统一表格，使用制表符可以获得更好的 token 效率：

```typescript
const largeData = {
  employees: [/* ... 大量员工数据 ... */]
}

const toonOutput = encode(largeData, { delimiter: '\t' })
```

在提示中告诉模型：

````markdown
数据采用 TOON 格式，字段使用制表符分隔：

```toon
[数据内容]
```
````

## 格式规范总结

### 缩进和空格

- 每级缩进：2 个空格（可配置）
- 冒号后：`key: value` 有一个空格
- 无尾随空格：任何行末都不应有空格
- 无尾随换行：输出末尾没有换行符

### 数组头部格式

- 原始数组：`key[N]:` 或 `key[N<delim>]:`
- 表格数组：`key[N]{field1,field2}:` 或 `key[N<delim>]{field1<delim>field2}:`
- 根数组：`[N]:` 或 `[N<delim>]:`

### 列表项格式

- 列表项标记：两个空格 + 连字符 + 空格（`"  - "`）
- 对象第一个字段放在连字符行
- 后续字段相对连字符缩进一级

## TypeScript 类型定义

```typescript
// 导出的类型
import type {
  JsonValue,          // JSON 值类型
  JsonObject,         // JSON 对象类型
  JsonArray,          // JSON 数组类型
  JsonPrimitive,      // JSON 原始类型
  EncodeOptions,      // 编码选项
  Delimiter,          // 分隔符类型
  DelimiterKey        // 分隔符键类型
} from '@byjohann/toon'

// 使用示例
const myData: JsonObject = {
  id: 1,
  name: 'Ada'
}

const options: EncodeOptions = {
  indent: 2,
  delimiter: '\t',
  lengthMarker: '#'
}
```

## 常见问题

### 1. TOON 适合所有场景吗？

不是。TOON 最适合：
- 结构统一的对象数组
- 向 LLM 传递数据（输入）
- 需要节省 token 的场景

TOON 不适合：
- 深度嵌套的复杂结构（JSON 可能更好）
- API 数据传输和存储（应使用 JSON）
- 让 LLM 生成输出（除非有明确指导）

### 2. 如何选择分隔符？

- **逗号**：默认选择，最通用
- **制表符**：数据中很少出现逗号时，或需要最大 token 效率时
- **管道符**：需要可读性但数据包含很多逗号时

### 3. Token 计数依赖什么？

Token 计数取决于模型的 tokenizer：
- 基准测试使用 GPT 的 `o200k_base` 编码
- 不同模型（如 SentencePiece）会有不同的节省比例
- 实际使用时建议根据目标模型进行测试

### 4. TOON 可以解析吗？

TOON v1 规范主要定义编码（生成）行为。解析（decoding）是可行的，但不在 v1 规范范围内。社区实现中可能包含解析器。

## 快速参考

```typescript
// 对象
{ id: 1, name: 'Ada' }          → id: 1
                                  name: Ada

// 嵌套对象
{ user: { id: 1 } }             → user:
                                    id: 1

// 原始数组（内联）
{ tags: ['foo', 'bar'] }        → tags[2]: foo,bar

// 表格数组（统一对象）
{ items: [                      → items[2]{id,qty}:
  { id: 1, qty: 5 },                1,5
  { id: 2, qty: 3 }                 2,3
]}

// 混合/非统一（列表）
{ items: [1, { a: 1 }, 'x'] }   → items[3]:
                                    - 1
                                    - a: 1
                                    - x

// 数组的数组
{ pairs: [[1, 2], [3, 4]] }     → pairs[2]:
                                    - [2]: 1,2
                                    - [2]: 3,4

// 根数组
['x', 'y']                      → [2]: x,y

// 空容器
{}                              → （空输出）
{ items: [] }                   → items[0]:

// 特殊引号
{ note: 'hello, world' }        → note: "hello, world"
{ items: ['true', true] }       → items[2]: "true",true
```

## 下一步

- 查看 [实现原理](./03-实现原理.md) 了解 TOON 的内部工作机制
- 查看 [额外思考](./04-额外思考.md) 了解深度分析和最佳实践
