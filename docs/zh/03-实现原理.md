# TOON 实现原理

本文档深入解析 TOON 编码器的内部实现机制，包括架构设计、核心算法和关键决策。

## 整体架构

TOON 编码器采用模块化设计，主要由以下几个核心模块组成：

```
src/
├── index.ts          # 公共 API 入口
├── normalize.ts      # 输入规范化
├── encoders.ts       # 核心编码逻辑
├── primitives.ts     # 原始值编码和字符串引号处理
├── writer.ts         # 行输出管理
├── types.ts          # TypeScript 类型定义
└── constants.ts      # 常量定义
```

### 处理流程

```
用户输入 (unknown)
    ↓
规范化 (normalize.ts)
    ↓
JSON 值 (JsonValue)
    ↓
编码 (encoders.ts + primitives.ts)
    ↓
行输出 (writer.ts)
    ↓
TOON 字符串
```

## 核心模块详解

### 1. index.ts - 公共 API

这是整个库的入口点，提供简洁的公共接口。

#### 主函数：encode()

```typescript
export function encode(input: unknown, options?: EncodeOptions): string {
  // 1. 规范化输入
  const normalizedValue = normalizeValue(input)

  // 2. 解析选项
  const resolvedOptions = resolveOptions(options)

  // 3. 编码为 TOON 格式
  return encodeValue(normalizedValue, resolvedOptions)
}
```

**职责**：
- 接受任意类型的输入
- 协调规范化和编码流程
- 处理选项的默认值

#### 选项解析

```typescript
function resolveOptions(options?: EncodeOptions): ResolvedEncodeOptions {
  return {
    indent: options?.indent ?? 2,              // 默认 2 空格缩进
    delimiter: options?.delimiter ?? ',',       // 默认逗号分隔符
    lengthMarker: options?.lengthMarker ?? false // 默认不使用长度标记
  }
}
```

### 2. normalize.ts - 输入规范化

规范化模块负责将任意 JavaScript 值转换为 JSON 兼容的值。这是确保输出一致性的关键步骤。

#### 规范化策略

```typescript
export function normalizeValue(value: unknown): JsonValue {
  // null 保持不变
  if (value === null) return null

  // 字符串和布尔值直接返回
  if (typeof value === 'string' || typeof value === 'boolean') {
    return value
  }

  // 数字：特殊处理
  if (typeof value === 'number') {
    // -0 规范化为 0
    if (Object.is(value, -0)) return 0

    // NaN 和 Infinity 转为 null
    if (!Number.isFinite(value)) return null

    return value
  }

  // BigInt：尝试转为 number，超出安全范围则转为字符串
  if (typeof value === 'bigint') {
    if (value >= Number.MIN_SAFE_INTEGER &&
        value <= Number.MAX_SAFE_INTEGER) {
      return Number(value)
    }
    return value.toString()  // 会被引号包裹（看起来像数字）
  }

  // Date → ISO 字符串
  if (value instanceof Date) {
    return value.toISOString()
  }

  // Array → 递归规范化每个元素
  if (Array.isArray(value)) {
    return value.map(normalizeValue)
  }

  // Set → 转为数组
  if (value instanceof Set) {
    return Array.from(value).map(normalizeValue)
  }

  // Map → 转为对象
  if (value instanceof Map) {
    return Object.fromEntries(
      Array.from(value, ([k, v]) => [String(k), normalizeValue(v)])
    )
  }

  // 普通对象 → 递归规范化每个属性
  if (isPlainObject(value)) {
    const result: Record<string, JsonValue> = {}
    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        result[key] = normalizeValue(value[key])
      }
    }
    return result
  }

  // 其他类型（function、symbol、undefined 等）→ null
  return null
}
```

#### 类型守卫

规范化模块还提供了一组类型守卫函数，用于运行时类型检查：

```typescript
// 原始值检测
export function isJsonPrimitive(value: unknown): value is JsonPrimitive {
  return value === null ||
         typeof value === 'string' ||
         typeof value === 'number' ||
         typeof value === 'boolean'
}

// 数组检测
export function isJsonArray(value: unknown): value is JsonArray {
  return Array.isArray(value)
}

// 对象检测
export function isJsonObject(value: unknown): value is JsonObject {
  return value !== null &&
         typeof value === 'object' &&
         !Array.isArray(value)
}
```

#### 数组类型检测

为了决定使用哪种数组编码格式，需要检测数组的内容类型：

```typescript
// 原始值数组
export function isArrayOfPrimitives(value: JsonArray): boolean {
  return value.every(item => isJsonPrimitive(item))
}

// 数组的数组
export function isArrayOfArrays(value: JsonArray): boolean {
  return value.every(item => isJsonArray(item))
}

// 对象数组
export function isArrayOfObjects(value: JsonArray): boolean {
  return value.every(item => isJsonObject(item))
}
```

### 3. primitives.ts - 原始值编码

这个模块处理原始值的编码和字符串引号规则，是 token 优化的关键。

#### 原始值编码

```typescript
export function encodePrimitive(value: JsonPrimitive, delimiter?: string): string {
  if (value === null) return 'null'

  if (typeof value === 'boolean') return String(value)  // 'true' 或 'false'

  if (typeof value === 'number') return String(value)

  // 字符串需要根据规则决定是否加引号
  return encodeStringLiteral(value, delimiter)
}
```

#### 智能引号决策

这是 TOON 的核心优化之一：

```typescript
export function encodeStringLiteral(value: string, delimiter: string = ','): string {
  if (isSafeUnquoted(value, delimiter)) {
    return value  // 不需要引号
  }
  return `"${escapeString(value)}"`  // 需要引号和转义
}
```

#### 安全无引号判断

```typescript
export function isSafeUnquoted(value: string, delimiter: string = ','): boolean {
  // 空字符串 → 需要引号
  if (!value) return false

  // 前导或尾随空格 → 需要引号
  if (value !== value.trim()) return false

  // 看起来像布尔值或 null → 需要引号
  if (value === 'true' || value === 'false' || value === 'null') return false

  // 看起来像数字 → 需要引号
  if (isNumericLike(value)) return false

  // 包含冒号（结构字符）→ 需要引号
  if (value.includes(':')) return false

  // 包含引号或反斜杠 → 需要引号
  if (value.includes('"') || value.includes('\\')) return false

  // 包含括号或大括号 → 需要引号
  if (/[[\]{}]/.test(value)) return false

  // 包含控制字符 → 需要引号
  if (/[\n\r\t]/.test(value)) return false

  // 包含活动分隔符 → 需要引号（分隔符感知！）
  if (value.includes(delimiter)) return false

  // 以连字符开头 → 需要引号（避免与列表标记混淆）
  if (value.startsWith('-')) return false

  // 通过所有检查 → 安全无引号
  return true
}
```

**关键特性：分隔符感知**

当使用不同分隔符时，引号规则会自动调整：
- 使用逗号分隔符时，包含逗号的字符串需要引号
- 使用制表符分隔符时，包含逗号的字符串不需要引号（但包含制表符的需要）

#### 字符串转义

```typescript
export function escapeString(value: string): string {
  return value
    .replace(/\\/g, '\\\\')      // 反斜杠 → \\
    .replace(/"/g, '\\"')        // 双引号 → \"
    .replace(/\n/g, '\\n')       // 换行符 → \n
    .replace(/\r/g, '\\r')       // 回车符 → \r
    .replace(/\t/g, '\\t')       // 制表符 → \t
}
```

#### 对象键编码

```typescript
export function encodeKey(key: string): string {
  if (isValidUnquotedKey(key)) {
    return key
  }
  return `"${escapeString(key)}"`
}

// 有效的无引号键：以字母或下划线开头，后跟字母、数字、下划线或点
function isValidUnquotedKey(key: string): boolean {
  return /^[A-Z_][\w.]*$/i.test(key)
}
```

#### 数组头部格式化

```typescript
export function formatHeader(
  length: number,
  options?: {
    key?: string
    fields?: readonly string[]
    delimiter?: string
    lengthMarker?: '#' | false
  }
): string {
  const { key, fields, delimiter = ',', lengthMarker = false } = options ?? {}

  let header = ''

  // 可选的键前缀
  if (key) {
    header += encodeKey(key)
  }

  // 数组长度，可选的长度标记和分隔符
  // 逗号分隔符是隐式的（不在头部显示）
  // 制表符和管道分隔符是显式的（在头部显示）
  header += `[${lengthMarker || ''}${length}${delimiter !== ',' ? delimiter : ''}]`

  // 可选的字段列表（表格格式）
  if (fields) {
    const quotedFields = fields.map(f => encodeKey(f))
    header += `{${quotedFields.join(delimiter)}}`
  }

  header += ':'

  return header
}
```

**示例**：
- `formatHeader(3)` → `[3]:`
- `formatHeader(3, { key: 'items' })` → `items[3]:`
- `formatHeader(2, { key: 'items', fields: ['id', 'name'] })` → `items[2]{id,name}:`
- `formatHeader(2, { delimiter: '\t', fields: ['id', 'name'] })` → `[2\t]{id\tname}:`
- `formatHeader(3, { lengthMarker: '#' })` → `[#3]:`

### 4. encoders.ts - 核心编码逻辑

这是最复杂的模块，包含所有编码策略的实现。

#### 主编码函数

```typescript
export function encodeValue(value: JsonValue, options: ResolvedEncodeOptions): string {
  // 原始值直接编码
  if (isJsonPrimitive(value)) {
    return encodePrimitive(value, options.delimiter)
  }

  // 复杂值需要行写入器
  const writer = new LineWriter(options.indent)

  if (isJsonArray(value)) {
    encodeArray(undefined, value, writer, 0, options)
  } else if (isJsonObject(value)) {
    encodeObject(value, writer, 0, options)
  }

  return writer.toString()
}
```

#### 对象编码

```typescript
export function encodeObject(
  value: JsonObject,
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  const keys = Object.keys(value)

  for (const key of keys) {
    encodeKeyValuePair(key, value[key], writer, depth, options)
  }
}

export function encodeKeyValuePair(
  key: string,
  value: JsonValue,
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  const encodedKey = encodeKey(key)

  if (isJsonPrimitive(value)) {
    // 原始值：key: value
    writer.push(depth, `${encodedKey}: ${encodePrimitive(value, options.delimiter)}`)
  } else if (isJsonArray(value)) {
    // 数组：使用数组编码逻辑
    encodeArray(key, value, writer, depth, options)
  } else if (isJsonObject(value)) {
    // 嵌套对象
    const nestedKeys = Object.keys(value)
    if (nestedKeys.length === 0) {
      // 空对象：key:
      writer.push(depth, `${encodedKey}:`)
    } else {
      // 非空对象：key: 后跟缩进的内容
      writer.push(depth, `${encodedKey}:`)
      encodeObject(value, writer, depth + 1, options)
    }
  }
}
```

#### 数组编码（核心算法）

数组编码是 TOON 最复杂的部分，需要根据内容选择最优格式：

```typescript
export function encodeArray(
  key: string | undefined,
  value: JsonArray,
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  // 空数组
  if (value.length === 0) {
    const header = formatHeader(0, { key, delimiter: options.delimiter, lengthMarker: options.lengthMarker })
    writer.push(depth, header)
    return
  }

  // 1. 原始值数组 → 内联格式
  if (isArrayOfPrimitives(value)) {
    encodeInlinePrimitiveArray(key, value, writer, depth, options)
    return
  }

  // 2. 数组的数组（所有内部数组都是原始值）→ 展开列表格式
  if (isArrayOfArrays(value)) {
    const allPrimitiveArrays = value.every(arr => isArrayOfPrimitives(arr))
    if (allPrimitiveArrays) {
      encodeArrayOfArraysAsListItems(key, value, writer, depth, options)
      return
    }
  }

  // 3. 对象数组 → 尝试表格格式，否则列表格式
  if (isArrayOfObjects(value)) {
    const header = detectTabularHeader(value)
    if (header) {
      // 统一对象 → 表格格式
      encodeArrayOfObjectsAsTabular(key, value, header, writer, depth, options)
    } else {
      // 非统一对象 → 列表格式
      encodeMixedArrayAsListItems(key, value, writer, depth, options)
    }
    return
  }

  // 4. 混合数组 → 列表格式
  encodeMixedArrayAsListItems(key, value, writer, depth, options)
}
```

#### 表格格式检测

这是决定是否使用表格格式的关键算法：

```typescript
export function detectTabularHeader(rows: readonly JsonObject[]): string[] | undefined {
  if (rows.length === 0) return undefined

  const firstRow = rows[0]
  const firstKeys = Object.keys(firstRow)

  if (firstKeys.length === 0) return undefined

  // 检查所有行是否满足表格格式要求
  if (isTabularArray(rows, firstKeys)) {
    return firstKeys  // 返回字段列表
  }

  return undefined
}

export function isTabularArray(
  rows: readonly JsonObject[],
  header: readonly string[]
): boolean {
  for (const row of rows) {
    const keys = Object.keys(row)

    // 所有对象必须有相同数量的键
    if (keys.length !== header.length) {
      return false
    }

    // 检查所有头部键在行中存在，且所有值都是原始类型
    for (const key of header) {
      if (!(key in row)) {
        return false
      }
      if (!isJsonPrimitive(row[key])) {
        return false  // 值必须是原始类型
      }
    }
  }

  return true
}
```

**表格格式的严格要求**：
1. 所有元素都是对象
2. 所有对象有相同的键集合（顺序可以不同）
3. 所有值都是原始类型（不能有嵌套对象或数组）

#### 表格格式编码

```typescript
export function encodeArrayOfObjectsAsTabular(
  prefix: string | undefined,
  rows: readonly JsonObject[],
  header: readonly string[],
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  // 写入头部：items[2]{id,name,price}:
  const headerStr = formatHeader(rows.length, {
    key: prefix,
    fields: header,
    delimiter: options.delimiter,
    lengthMarker: options.lengthMarker
  })
  writer.push(depth, headerStr)

  // 写入每一行的值
  writeTabularRows(rows, header, writer, depth + 1, options)
}

function writeTabularRows(
  rows: readonly JsonObject[],
  header: readonly string[],
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  for (const row of rows) {
    // 按头部顺序提取值
    const values = header.map(key => row[key])
    // 编码并用分隔符连接
    const joinedValue = joinEncodedValues(values as JsonPrimitive[], options.delimiter)
    writer.push(depth, joinedValue)
  }
}
```

#### 列表格式编码

对于非统一或混合数组：

```typescript
export function encodeMixedArrayAsListItems(
  prefix: string | undefined,
  items: readonly JsonValue[],
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  // 写入头部
  const header = formatHeader(items.length, {
    key: prefix,
    delimiter: options.delimiter,
    lengthMarker: options.lengthMarker
  })
  writer.push(depth, header)

  // 每个元素作为列表项
  for (const item of items) {
    if (isJsonPrimitive(item)) {
      writer.push(depth + 1, `- ${encodePrimitive(item, options.delimiter)}`)
    } else if (isJsonArray(item)) {
      if (isArrayOfPrimitives(item)) {
        const inline = formatInlineArray(item, options.delimiter, undefined, options.lengthMarker)
        writer.push(depth + 1, `- ${inline}`)
      }
    } else if (isJsonObject(item)) {
      encodeObjectAsListItem(item, writer, depth + 1, options)
    }
  }
}
```

#### 列表项中的对象编码

这是一个特殊的编码模式，第一个字段放在连字符行：

```typescript
export function encodeObjectAsListItem(
  obj: JsonObject,
  writer: LineWriter,
  depth: Depth,
  options: ResolvedEncodeOptions
): void {
  const keys = Object.keys(obj)

  if (keys.length === 0) {
    writer.push(depth, '-')  // 空对象
    return
  }

  // 第一个字段放在连字符行
  const firstKey = keys[0]
  const encodedKey = encodeKey(firstKey)
  const firstValue = obj[firstKey]

  if (isJsonPrimitive(firstValue)) {
    // - key: value
    writer.push(depth, `- ${encodedKey}: ${encodePrimitive(firstValue, options.delimiter)}`)
  } else if (isJsonArray(firstValue)) {
    if (isArrayOfPrimitives(firstValue)) {
      // - key[N]: v1,v2,...
      const formatted = formatInlineArray(firstValue, options.delimiter, firstKey, options.lengthMarker)
      writer.push(depth, `- ${formatted}`)
    } else if (isArrayOfObjects(firstValue)) {
      const header = detectTabularHeader(firstValue)
      if (header) {
        // - key[N]{fields}:
        //   row1
        //   row2
        const headerStr = formatHeader(firstValue.length, {
          key: firstKey,
          fields: header,
          delimiter: options.delimiter,
          lengthMarker: options.lengthMarker
        })
        writer.push(depth, `- ${headerStr}`)
        writeTabularRows(firstValue, header, writer, depth + 1, options)
      } else {
        // - key[N]:
        //   - item1
        //   - item2
        writer.push(depth, `- ${encodedKey}[${firstValue.length}]:`)
        for (const item of firstValue) {
          encodeObjectAsListItem(item, writer, depth + 1, options)
        }
      }
    }
    // ... 其他数组类型处理
  } else if (isJsonObject(firstValue)) {
    // - key:
    //     nested content (depth + 2!)
    writer.push(depth, `- ${encodedKey}:`)
    encodeObject(firstValue, writer, depth + 2, options)  // 注意：depth + 2
  }

  // 剩余字段在缩进行
  for (let i = 1; i < keys.length; i++) {
    const key = keys[i]
    encodeKeyValuePair(key, obj[key], writer, depth + 1, options)
  }
}
```

**关键设计**：
- 第一个字段和 `- ` 在同一行
- 后续字段相对连字符缩进一级（depth + 1）
- 如果第一个字段是对象，其内容缩进两级（depth + 2）

### 5. writer.ts - 行输出管理

LineWriter 是一个简单但重要的工具类，负责管理缩进和行的累积。

```typescript
export class LineWriter {
  private lines: string[] = []
  private indentSize: number

  constructor(indentSize: number = 2) {
    this.indentSize = indentSize
  }

  // 添加一行，自动处理缩进
  push(depth: number, content: string): void {
    const indent = ' '.repeat(depth * this.indentSize)
    this.lines.push(`${indent}${content}`)
  }

  // 转换为最终字符串
  toString(): string {
    return this.lines.join('\n')
  }
}
```

**设计要点**：
- 自动计算每行的缩进空格数
- 使用换行符连接所有行
- 末尾没有额外的换行符

## 关键算法和优化

### 1. 智能格式选择算法

TOON 的核心优化来自于根据数据结构自动选择最优格式：

```
检查数组内容
    ↓
所有元素都是原始值？
    是 → 内联格式：key[N]: v1,v2,v3
    否 ↓
所有元素都是原始值数组？
    是 → 展开列表格式
    否 ↓
所有元素都是对象？
    是 → 检查表格条件
        ├─ 满足 → 表格格式：key[N]{fields}: ...
        └─ 不满足 → 列表格式：key[N]: - ...
    否 ↓
混合数组 → 列表格式
```

### 2. 表格格式优化

表格格式是最大的 token 节省来源：

**传统 JSON（重复键）**：
```json
[
  {"id": 1, "name": "Ada"},
  {"id": 2, "name": "Bob"}
]
```
Token 消耗：每行都重复 `"id"` 和 `"name"`

**TOON 表格（键只出现一次）**：
```
[2]{id,name}:
  1,Ada
  2,Bob
```
Token 消耗：键只在头部出现一次

**节省计算**：
- 100 条记录，每条 5 个字段
- JSON：500 次字段名重复
- TOON：5 次字段名（仅头部）
- 节省：495 次 × 平均字段名长度的 token

### 3. 分隔符感知引号

不同分隔符下，引号需求不同：

```typescript
const data = { items: ['a,b', 'c\td', 'e|f'] }

// 逗号分隔符
encode(data, { delimiter: ',' })
// items[3]: "a,b",c\td,e|f
// 只有包含逗号的需要引号

// 制表符分隔符
encode(data, { delimiter: '\t' })
// items[3\t]: a,b "c\td" e|f
// 只有包含制表符的需要引号

// 管道分隔符
encode(data, { delimiter: '|' })
// items[3|]: a,b|c\td|"e|f"
// 只有包含管道的需要引号
```

这确保了最少的引号使用，进一步优化 token。

### 4. 递归表格格式

表格格式可以递归应用到嵌套结构：

```typescript
const data = {
  orders: [
    {
      id: 1,
      items: [
        { sku: 'A', qty: 2 },
        { sku: 'B', qty: 1 }
      ]
    }
  ]
}
```

输出：
```
orders[1]:
  - id: 1
    items[2]{sku,qty}:
      A,2
      B,1
```

内层的 `items` 数组也使用了表格格式，最大化 token 节省。

## 性能考虑

### 时间复杂度

对于包含 N 个元素的数据结构：

1. **规范化**：O(N) - 遍历每个值一次
2. **类型检查**：O(N) - 每个值检查类型
3. **表格检测**：O(M × K)，M 是数组长度，K 是字段数
4. **编码**：O(N) - 每个值编码一次

总体：O(N)，其中 N 是数据结构中的总元素数

### 空间复杂度

- **规范化**：创建新的规范化对象，O(N)
- **LineWriter**：存储所有行，O(L)，L 是输出行数
- **字符串拼接**：JavaScript 引擎优化，现代实现接近 O(1)

总体：O(N + L)

### 优化技术

1. **惰性字符串拼接**：使用数组存储行，最后一次性 join
2. **类型守卫**：使用 TypeScript 类型守卫提高类型推断
3. **早期返回**：满足条件立即返回，避免不必要的检查
4. **正则表达式缓存**：正则表达式字面量被引擎缓存

## 设计决策

### 1. 为什么是确定性输出？

TOON 的输出是完全确定的：相同的输入总是产生相同的输出。

**好处**：
- 可缓存
- 可比较（diff、测试）
- 可预测

**实现**：
- 对象键顺序保持遇到顺序
- 表格检测逻辑固定
- 引号规则明确

### 2. 为什么分离规范化和编码？

将规范化和编码分离有多个优势：

**清晰的职责**：
- 规范化：处理 JavaScript 特有类型
- 编码：处理 JSON 值到 TOON 字符串

**易于测试**：
- 可以独立测试每个阶段
- 可以直接测试编码器使用标准 JSON

**扩展性**：
- 其他语言移植只需实现类似的规范化
- 编码逻辑保持不变

### 3. 为什么使用 LineWriter？

LineWriter 抽象了缩进管理：

**优势**：
- 编码器不需要手动计算空格
- 容易改变缩进大小
- 清晰的深度参数

**简单性**：
- 实现简单（不到 20 行）
- 性能足够（数组 join 很快）

### 4. 为什么表格格式要求这么严格？

表格格式要求所有对象有相同的原始值字段：

**原因**：
- **一致性**：确保每行有相同的列数
- **可解析性**：解析器可以依赖固定的字段顺序
- **LLM 友好**：LLM 更容易理解统一的表格
- **token 优化**：只有统一结构才能最大化节省

**权衡**：
- 非统一对象退化为列表格式
- 列表格式仍比 JSON 更紧凑（去除括号）

## 测试策略

TOON 使用 Vitest 进行全面测试：

### 测试覆盖

1. **原始值编码**
   - 字符串、数字、布尔值、null
   - 引号规则
   - 转义字符

2. **对象编码**
   - 简单对象
   - 嵌套对象
   - 空对象

3. **数组编码**
   - 原始值数组
   - 对象数组（表格和列表）
   - 数组的数组
   - 混合数组

4. **类型转换**
   - BigInt、Date、Set、Map
   - NaN、Infinity
   - undefined、function、symbol

5. **选项**
   - 自定义缩进
   - 不同分隔符
   - 长度标记

6. **边缘情况**
   - 空容器
   - Unicode 和 emoji
   - 特殊字符

## 总结

TOON 的实现体现了以下设计原则：

1. **模块化**：清晰的职责分离
2. **类型安全**：充分利用 TypeScript 类型系统
3. **确定性**：可预测、可缓存的输出
4. **优化优先**：智能选择最优格式
5. **简单性**：避免过度设计，核心逻辑清晰
6. **可扩展性**：易于移植到其他语言

通过这些设计，TOON 实现了在保持简单性的同时，提供 30-60% 的 token 节省，并提高了 LLM 对结构化数据的理解准确度。
